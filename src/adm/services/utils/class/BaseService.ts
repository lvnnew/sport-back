/* eslint-disable @typescript-eslint/ban-types */
import {HooksUtils} from '../../getHooksUtils';
import {Context, ServiceConfig} from '../../types';
import {Prisma, PrismaPromise} from '@prisma/client';
import {toPrismaRequest} from '../../../../utils/prisma/toPrismaRequest';
import {IAllRequestArgs} from '../../../../utils/types';
import {toPrismaTotalRequest} from '../../../../utils/prisma/toPrismaTotalRequest';
import {ListMetadata} from '../../../../generated/graphql';
import {PartialFieldsInRecord} from '../../../../types/utils';
import * as R from 'ramda';
import dayjs from 'dayjs';
import Entity from '../../../../types/Entity';
import {v4 as uuidv4} from 'uuid';

type WithID = { id: bigint | string | number };

export type BaseEntity = WithID;
export type BaseMU = WithID;
export type BaseMR = WithID;

const fakePromise = Promise.resolve<any>(null);

export class BaseService<E extends BaseEntity & Record<string, any>, //  entity
  QA extends IAllRequestArgs, // query all entities arguments
  MC extends {}, // mutation create entity arguments
  MU extends BaseMU, // mutation update entity arguments
  MR extends BaseMR, // mutation remove entity arguments
  SMC extends {} = MC, // strict mutation create entity arguments
  SMU extends BaseMU = MU, // strict mutation create entity arguments
  AutoDefPart = any, // todo: do something about it
  MutationCreateArgsWithoutAutodefinable extends Record<string, any> = any, // todo: do something about it
  MutationUpdateArgsWithoutAutodefinable extends Record<string, any> = any, // todo: do something about it
  StrictCreateArgsWithoutAutodefinable = any, // todo: do something about it
> extends HooksUtils<E, QA, MC, MU, MR, SMC, SMU> {
  protected getSearchString = (entry: Record<string, any>) => {
    return [
      ...R.toPairs(R.pick(this.config.otherFields, entry))
        .map((el) => (el[1] as any)?.toString()?.toLowerCase() ?? ''),
      ...R.toPairs(R.pick(this.config.dateFields, entry))
        .map((el) => dayjs(el[1] as Date).utc().format('DD.MM.YYYY') ?? ''),
    ].join(' ');
  };

  protected augmentByDefault = async <T>(
    currentData: Record<string, any>,
  ): Promise<T & AutoDefPart> => currentData as T & AutoDefPart;

  constructor(
    protected ctx: Context,
    protected prismaService: any, // todo: do something about it PrismaClient[keyof PrismaClient],
    protected config: ServiceConfig,
  ) {
    super();
  }

  // далее методы которые не меняются не от чего.

  all = async (
    params: QA = {} as QA, // todo: why {} as QA
  ): Promise<E[]> => {
    return this.prismaService.findMany(
      toPrismaRequest(await this._hooks.changeListFilter(this.ctx, params), {noId: false}),
    ) as unknown as Promise<E[]>;
  };

  findOne = async (
    params: QA = {} as QA, // todo: why {} as QA
  ): Promise<E | null> => {
    return this.prismaService.findFirst(toPrismaRequest(
      await this._hooks.changeListFilter(this.ctx, params),
      {noId: false},
    )) as unknown as E; // todo: fix unknown
  };

  findOneRequired = async (
    params: QA = {} as QA, // todo: why {} as QA
  ): Promise<E> => {
    const found = await this.findOne(params);

    if (!found) {
      throw new Error(`There is no entry with "${JSON.stringify(params)}" filter`);
    }

    return found;
  };

  get = async (
    id: E['id'],
  ): Promise<E | null> => {
    return this.findOne({filter: {id}} as unknown as QA); // todo: why as unknown as QA
  };

  getRequired = async (
    id: E['id'],
  ): Promise<E> => {
    const found = await this.get(id);

    if (!found) {
      throw new Error(`There is no entry with "${id}" id`);
    }

    return found;
  };

  count = async (
    params: QA = {} as QA, // todo: why {} as QA
  ): Promise<number> => {
    return this.prismaService.count(toPrismaTotalRequest(await this._hooks.changeListFilter(this.ctx, params)));
  };

  meta = async (
    params: QA = {} as QA, // todo: why {} as QA
  ): Promise<ListMetadata> => {
    return this.count(params).then(count => ({count}));
  };

  create = async (
    data: MutationCreateArgsWithoutAutodefinable,
    byUser = false,
  ): Promise<E> => {
    // clear from fields forbidden for user
    const cleared = byUser ?
      R.omit(this.config.forbiddenForUserFields, data) as any /* AllowedForUserCreateInput*/ :
      data; // todo: fix type

    // Augment with default field
    const augmentedByDefault: any /* ReliableCreateUserInput*/ = await this.augmentByDefault(cleared);

    const processedData = await this._hooks.beforeCreate(this.ctx, augmentedByDefault);

    let createOperation;
    if (this.config.autogeneratedStringId) {
      createOperation = this.prismaService.create({
        data: {
          id: uuidv4(),
          ...R.mergeDeepLeft(
            processedData,
            this.config.autogeneratedStringId ? {
              search: this.getSearchString(processedData),
            } : {},
          ),
        } as any, // todo: fix type
      });
    } else {
      createOperation = this.prismaService.create({
        data: R.mergeDeepLeft(
          processedData,
          this.config.autogeneratedStringId ? {
            search: this.getSearchString(processedData),
          } : {},
        ) as any, // todo: fix type
      });
    }

    const operations = [
      createOperation,
      ...(await this._hooks.additionalOperationsOnCreate(this.ctx, processedData as MC)),
    ];

    const [result] = await this.ctx.prisma.$transaction(operations as any);

    if (!result) {
      throw new Error('There is no such entity');
    }

    await Promise.all([
      // getDefaultValuesWithSearchJoined('processedData')
      //   ? `
      // update search. earlier we do not have id
      this.prismaService.update({
        where: {id: result.id},
        data: this.config.autogeneratedStringId ? {
          search: this.getSearchString(result),
        } : {},
      }),
      this.config.auditable ?
        this.ctx.service('auditLogs').addCreateOperation({
          entityTypeId: this.config.entityTypeId as Entity, // todo: fix type
          entityId: result.id,
          actionData: data,
        }) : fakePromise,
    ]);

    await this._hooks.afterCreate(this.ctx, result as E);

    return result as E;
  };

  createMany = async (
    entries: StrictCreateArgsWithoutAutodefinable[],
    byUser = false,
  ): Promise<Prisma.BatchPayload> => {
    // clear from fields forbidden for user
    const clearedData = byUser ? entries.map(data => R.omit(this.config.forbiddenForUserFields, data)) : entries;

    // Augment with default field
    const augmentedByDefault = await Promise.all(
      clearedData.map(el => this.augmentByDefault(el)),
    ) as any[]; // todo: as SMU

    let result;
    if (this.config.autogeneratedStringId) {
      result = await this.prismaService.createMany({
        data: augmentedByDefault.map(data => ({
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          id: uuidv4(),
          ...R.mergeDeepLeft(
            data,
            this.config.withSearch ? {
              search: this.getSearchString(data),
            } : {},
          ),
        })) as any, // todo: fix type
        skipDuplicates: true});
    } else {
      result = await this.prismaService.createMany({
        data: augmentedByDefault.map(data => R.mergeDeepLeft(
          data,
          this.config.withSearch ? {
            search: this.getSearchString(data),
          } : {},
        )) as any, // todo: fix type
        skipDuplicates: true,
      });
    }

    if (!result) {
      throw new Error('There is no such entity');
    }

    return result;
  };

  update = async (
    data: MutationUpdateArgsWithoutAutodefinable,
    byUser = false,
  ): Promise<E> => {
    // Get db version
    const dbVersion = await this.getRequired(data.id);

    // clear from fields forbidden for user
    const cleared = byUser ? R.omit(this.config.forbiddenForUserFields, data) : data;

    // Augment with default field
    const augmentedByDefault = await this.augmentByDefault(cleared) as any; // todo: fix type

    // augment data by fields from db
    const augmented: SMU = R.mergeLeft(augmentedByDefault, dbVersion);

    const processedData = await this._hooks.beforeUpdate(this.ctx, augmented);

    const {id, ...rest} = processedData;

    const updateOperation = this.prismaService.update({
      data: R.mergeDeepLeft(
        this.config.withSearch ? {
          search: this.getSearchString(processedData),
        } : {},
        rest,
      ) as any, // todo: fix type
      where: {
        id: id as any, // todo: fix type
      },
    });

    const operations = [
      updateOperation,
      this.config.auditable ? this.ctx.service('auditLogs').addUpdateOperation({
        entityTypeId: this.config.entityTypeId as Entity, // todo: fix type
        entityId: data.id,
        actionData: data,
      }) : fakePromise,
      ...(await this._hooks.additionalOperationsOnUpdate(
        this.ctx,
        processedData as any, // todo: fix type
      )),
      // todo: следующий код добавляется в следующем классе в хуки, нужно проверить с помощею теста
      //   entity.type === 'document'
      ...(await this.getPostOperations(processedData)),
    ];

    const [result] = await this.ctx.prisma.$transaction(operations as any);

    if (!result) {
      throw new Error('There is no such entity');
    }

    await Promise.all([
      this._hooks.afterUpdate(this.ctx, result as any), // todo: fix
    ]);

    return result as E;
  };

  upsert = async (
    data: PartialFieldsInRecord<MutationUpdateArgsWithoutAutodefinable, 'id'>,
    byUser = false,
  ): Promise<E> => {
    // todo: external search
    // Get db version
    const dbVersion = data.id ? await this.get(data.id) : null;

    // clear from fields forbidden for user
    const cleared = byUser ? R.omit(this.config.forbiddenForUserFields, data) : data;

    // Augment with default field
    const augmentedByDefault = await this.augmentByDefault(cleared) as any; // todo: fix type check

    // augment data by fields from db
    const augmented = R.mergeLeft(augmentedByDefault, dbVersion || {} as E) as unknown as MC & SMU;

    const processedData = await this._hooks.beforeUpsert(this.ctx, {createData: augmented, updateData: augmented});
    const createData = {
      ...processedData.createData,
      search: this.getSearchString(processedData.createData),
    };
    const updateData = {
      ...processedData.updateData,
      search: this.getSearchString(processedData.updateData),
    };

    const result = await this.prismaService.upsert({
      create: createData as any, // todo: fix type
      update: updateData as any, // todo: fix type
      where: {id: data.id},
    });

    if (!result) {
      throw new Error('There is no such entity');
    }

    return result as unknown as E;
  };

  upsertAdvanced = async (
    filter: IAllRequestArgs['filter'],
    data: MutationCreateArgsWithoutAutodefinable,
    byUser = false,
  ): Promise<E> => {
    const cnt = await this.count({filter} as QA);

    if (cnt > 1) {
      throw new Error(`There is more then one entity (${cnt}) that fits filter "${JSON.stringify(filter)}"`);
    } else if (cnt === 0) {
      return this.create(data as MutationCreateArgsWithoutAutodefinable, byUser);
    } else {
      const dbVersion = await this.findOneRequired({filter} as QA);
      return this.update({
        ...data,
        id: dbVersion.id,
      } as unknown as MutationUpdateArgsWithoutAutodefinable, byUser);
    }
  };

  delete = async (
    params: MR,
  ): Promise<E> => {
    await this._hooks.beforeDelete(this.ctx, params);

    const deleteOperation = this.prismaService.delete({
      where: {
        id: params.id as any, // todo: fix type
      },
    });

    const operations = [
      deleteOperation,
      this.config.auditable ? this.ctx.service('auditLogs').addDeleteOperation({
        entityTypeId: this.config.entityTypeId as Entity, // todo: fix type
        entityId: params.id as number | string, // todo: fix type
      }) : fakePromise,
      ...(await this._hooks.additionalOperationsOnDelete(this.ctx, params)),
      // todo: следующий код добавляется в следующем классе в хуки, нужно проверить с помощею теста
      // entity.type === 'document'
      // ...(await getUnPostOperations(ctx, params.id)),
      ...(await this.getUnPostOperations(params.id)),
    ];

    const entity = await this.get(params.id);

    if (!entity) {
      throw new Error(`There is no entity with "${params.id}" id`);
    }

    const [result] = await this.ctx.prisma.$transaction(operations as any);

    if (!result) {
      throw new Error('There is no such entity');
    }

    await this._hooks.afterDelete(this.ctx, entity);

    return entity;
  };

  // fake methods for the document, they are populated in the next document class
  private getPostOperations = async (_data: SMU): Promise<PrismaPromise<any>[]> => [];
  private getUnPostOperations = async (_id: E['id']): Promise<PrismaPromise<any>[]> => [];
}
